// AUTOMATICALLY GENERATED, DO NOT EDIT
// This file was generated by c2singlefile
// https://github.com/Depaulicious/c2singlefile

// Files included here:
// * utils.h
// * utils.c
// * hashtable.h
// * hashtable.c
// * ramfs.h
// * ramfs.c
// * ramfs_wrapped.h
// * ramfs_wrapped.c
// * main.c

#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Macros
// From utils.h

#define BASE_BUF_SIZE 64

// Needed by SuperFastHash
#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__) \
  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)
#define get16bits(d) (*((const uint16_t *) (d)))
#endif

#if !defined (get16bits)
#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)\
                       +(uint32_t)(((const uint8_t *)(d))[0]) )
#endif

// From hashtable.h

#define BASE_HT_SIZE 64

// From ramfs.h

#define MAX_NAME_LENGTH 255
#define FIND_ARRAY_SIZE 64

// Datatypes
// From hashtable.h

typedef struct _ht_item {
    void *key;
    void *val;
} ht_item_t;

typedef struct _ht {
    size_t size;
    size_t used;
    ht_item_t *body;
} ht_t;

typedef struct _ht_item_list
{
    struct _ht_item_list *next;
    ht_item_t            *item;
} ht_item_list_t;

// From ramfs.h

typedef enum _node_type {
    TYPE_DIR,
    TYPE_FILE
} fs_node_type_t;

typedef union _fs_node_data {
    void *raw;
    char *content;
    ht_t *children;
} fs_node_data_u;

typedef struct _fs_node {
    char *name;
    struct _fs_node *parent;
    fs_node_type_t type;
    fs_node_data_u data;
    uint8_t depth;
} fs_node_t;

// Declarations
// From utils.h

void *malloc_or_die(size_t size);
void *calloc_or_die(size_t nmemb, size_t size);
void *realloc_or_die(void *ptr, size_t size);
ssize_t getline_depau(char **lineptr, size_t *n, FILE *stream);
char *strtok_depau(char *s, const char *delim, char **save_ptr);
char *strtok_escape(char *s, const char *delim, char **save_ptr, char escape_char);
char *readcmd(char *s, char **save_ptr);
char *strcat_auto(int n_args, ...);

void print_status(int ret);
void call_with_1(int (*func)(fs_node_t *, char *string), fs_node_t *root, char *cmd);
void call_with_2(int (*func)(fs_node_t *, char *, char *string), fs_node_t *root, char *cmd);

uint32_t hash(const char * data, size_t len);

#ifdef DEBUG
unsigned long get_linecount();
void increment_linecount();
#endif

// From hashtable.h

ht_t       *ht_new();
void        ht_del(ht_t *t);
ht_item_t  *_ht_body_new(size_t size);
size_t      _ht_index(ht_t *t, void *key);
void       *ht_getitem(ht_t *t, void *key);
uint8_t     ht_setitem(ht_t *t, void *key, void *val);
void        ht_replitem(ht_t *t, void *key, void *val);
void        ht_delitem(ht_t *t, void *key);
void        ht_grow(ht_t *t, size_t newsize);

void _ht_replitem(ht_t *t, size_t pos, void *key, void *val);

#ifdef DEBUG
void dump_hashtable(ht_t *t);
#endif

// From ramfs.h

int ramfs_create(fs_node_t *root, char *path);
int ramfs_create_dir(fs_node_t *root, char *path);
char * ramfs_read(fs_node_t *root, char *path);
int ramfs_write(fs_node_t *root, char *path, char *content);
int ramfs_delete(fs_node_t *root, char *path);
int ramfs_delete_r(fs_node_t *root, char *path);
char **ramfs_find(fs_node_t *root, char *keyword, size_t *nres);
fs_node_t  *ramfs_mkfs();

fs_node_t *_ramfs_resolve_node(fs_node_t *root, char *path, char **newname);
char       *_ramfs_getpath(fs_node_t *node);
fs_node_t  *_ramfs_mknode(fs_node_t *parent, char *name, fs_node_type_t type, void *data);
int _ramfs_rmnode(fs_node_t *node, uint8_t no_rm_from_parent);
int _ramfs_rmnode_r(fs_node_t *node, uint8_t no_rm_from_parent);
size_t _ramfs_find(fs_node_t *node, char *curpath, char *keyword, char ***results, size_t *len, size_t *pos);
int _pathcmp(const void *p1, const void *p2);


#ifdef DEBUG
void dump_node(fs_node_t *node);
#endif

// From ramfs_wrapped.h

void ramfs_create_w(fs_node_t *root, char *cmd);
void ramfs_create_dir_w(fs_node_t *root, char *cmd);
void ramfs_read_w(fs_node_t *root, char *cmd);
void ramfs_write_w(fs_node_t *root, char *cmd);
void ramfs_delete_w(fs_node_t *root, char *cmd);
void ramfs_delete_r_w(fs_node_t *root, char *cmd);
void ramfs_find_w(fs_node_t *root, char *cmd);

// Definitions
// From utils.c

// Shortcuts for commonly used functions

/*
 * {m,c,re}alloc_or_die: wrappers for malloc, calloc, realloc
 * that `exit(1)` if memory allocation failed.
 */

inline void *malloc_or_die(size_t size) {
    void *ptr = malloc(size);
    if (ptr == NULL) {
        exit(1);
    }
    return ptr;
}

inline void *calloc_or_die(size_t nmemb, size_t size) {
    void *ptr = calloc(nmemb, size);
    if (ptr == NULL) {
        exit(1);
    }
    return ptr;
}

inline void *realloc_or_die(void *ptr, size_t size) {
    void *newptr = realloc(ptr, size);
    if (newptr == NULL) {
        exit(1);
    }
    return newptr;
}

/*
 * Implementation of POSIX `getline`.
 * Reads `stream` until a new line character is found.
 * `**lineptr` is where the read line will be stored. It must be
 * allocated with {m,c,re}alloc. It will be realloc'd if there's
 * not enough space to store the line. `*n` is its initial size.
 * It will be updated if a realloc was needed.
 * Returns the number of characters read, or -1 on error.
 */

ssize_t getline_depau(char **lineptr, size_t *n, FILE *stream) {
    ssize_t charsread;
    char *ptr;

    if (*lineptr == (char *) NULL) {
        *lineptr = malloc_or_die(BASE_BUF_SIZE * sizeof(char));
    }
    if (*n == 0)
        *n = BASE_BUF_SIZE;

    ptr = *lineptr;

    // charsread starts at 1 so we are already counting the terminator
    for (charsread = 1;; charsread++) {
        char c = (char) getc(stream);

        // allocate more space for command line
        if ((size_t) charsread > *n - 2) {
            *n += BASE_BUF_SIZE * sizeof(char);
            *lineptr = realloc_or_die(*lineptr, *n);
            ptr = *lineptr + (charsread - 1);
        }

        if (c == EOF) {
            *ptr = '\0';
            return -1;
        }

        if (c == '\n') {
            *ptr = '\0';
            return charsread;
        }

        *ptr = c;
        ptr++;
    }
}

/*
 * Reimplementation of POSIX `strtok_r`.
 */

char *strtok_depau(char *s, const char *delim, char **save_ptr) {
    return strtok_escape(s, delim, save_ptr, (char)(intptr_t) NULL);
}

/*
 * Implementation of `strtok_r` that also allows an `escape_char`
 * to be specified. If a delimiter character is preceded by `escape_char`,
 * it will not be considered a delimiter.
 */

char *strtok_escape(char *s, const char *delim, char **save_ptr, char escape_char) {
    char *end;
    size_t span = 0;
    if (s == NULL)
        s = *save_ptr;
    if (*s == '\0') {
        *save_ptr = s;
        return NULL;
    }
    // Scan leading delimiters.
    s += strspn(s, delim);
    if (*s == '\0') {
        *save_ptr = s;
        return NULL;
    }
    // Find the end of the token.
    span = strcspn(s, delim);
    if (span > 0) {
        // Check for escape character
        end = s + span;
        while (escape_char != (char)(intptr_t) NULL && *(end-1) == escape_char) {
            end++;
            end = end + strcspn(end, delim);
        }
    } else {
        end = s;
    }
    if (*end == '\0') {
        *save_ptr = end;
        return s;
    }
    // Terminate the token and make *s point past it.
    *end = '\0';
    *save_ptr = end + 1;
    return s;
}

/*
 * Wraps `strtok_escape` in order to read the parts of a command from input.
 * Returns pointers to the beginning of each space-separated token of input.
 * If a token starts with a double-quote, the whole substring surrounded by
 * double-quotes is returned. Double-quotes can be escaped with \
 */

char *readcmd(char *s, char **save_ptr) {
    u_int8_t quoted = 0;

    // Check current token starts with ". If it does, consider it as one token
    if (s != NULL) {
        if (*s == '"') {
            s++;
            quoted = 1;
        }
    } else {
        if (**save_ptr == '"') {
            (*save_ptr)++;
            quoted = 1;
        }
    }
    if (quoted)
        return strtok_escape(s, "\"", save_ptr, '\\');
    return strtok_depau(s, " \n", save_ptr);
}

/*
 * Concatenate `s2` on top of `s1` into a new string.
 * A pointer to the new string is returned.
 */

char *strcat_auto(int n_args, ...) {
    va_list ap;
    char *ptr;
    size_t pos = 0;
    size_t len = BASE_BUF_SIZE;
    char *newstr = malloc_or_die(len*sizeof(char));

    va_start(ap, n_args);

    // Iterate over the two strings
    for (int i = 0; i < n_args; i++) {
        ptr = va_arg(ap, char *);

        if (ptr == NULL)
            continue;

        // Copy characters from strings
        for (; *ptr != '\0'; ptr++) {
            // If no room for next char + terminator, realloc
            if (pos + 2 > len) {
                len += BASE_BUF_SIZE;
                newstr = realloc_or_die(newstr, len);
            }
            newstr[pos] = *ptr;
            pos++;
        }
    }
    newstr[pos] = '\0';
    va_end(ap);
    return newstr;
}


/*
 * Print "ok" if ret is 0, "no" if ret < 0, "ok `ret`" if ret > 0.
 */

inline void print_status(int ret) {
    if (ret < 0)
        printf("no\n");
    else if (ret == 0)
        printf("ok\n");
    else
        printf("ok %i\n", ret);
}

/*
 * Reads one string argument from `cmd`, then calls `func` passing
 * `root` and that argument to it.
 */

inline void call_with_1(int (*func)(fs_node_t *, char *), fs_node_t *root, char *cmd) {
    char *save_ptr;
    char *arg1 = readcmd(cmd, &save_ptr);
    int ret = (*func)(root, arg1);
    print_status(ret);
}

/*
 * Reads two string arguments from `cmd`, then calls `func` passing
 * `root` and those arguments to it.
 */

inline void call_with_2(int (*func)(fs_node_t *, char *, char *), fs_node_t *root, char *cmd) {
    char *save_ptr;
    char *arg1 = readcmd(cmd, &save_ptr);
    char *arg2 = readcmd(NULL, &save_ptr);

    int ret = (*func)(root, arg1, arg2);
    print_status(ret);
}

/*
 * SuperFastHash by Paul Hsieh
 * http://www.azillionmonkeys.com/qed/hash.html
 */
uint32_t hash(const char *data, size_t len) {
    int rem;
    uint32_t tmp;
    uint32_t hash = (uint32_t) len;

    if (len <= 0 || data == NULL) return 0;

    rem = (int) len & 3;
    len >>= 2;

    /* Main loop */
    for (;len > 0; len--) {
        hash  += get16bits(data);
        tmp    = (get16bits(data+2) << 11) ^ hash;
        hash   = (hash << 16) ^ tmp;
        data  += 2*sizeof (uint16_t);
        hash  += hash >> 11;
    }

    /* Handle end cases */
    switch (rem) {
        case 3: hash += get16bits(data);
            hash ^= hash << 16;
            hash ^= ((signed char)data[sizeof (uint16_t)]) << 18;
            hash += hash >> 11;
            break;
        case 2: hash += get16bits(data);
            hash ^= hash << 11;
            hash += hash >> 17;
            break;
        case 1: hash += (signed char)*data;
            hash ^= hash << 10;
            hash += hash >> 1;
        default:break;
    }

    /* Force "avalanching" of final 127 bits */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    return hash;
}

#ifdef DEBUG
unsigned long linecount = 0;

unsigned long get_linecount() {
    return linecount;
}

void increment_linecount() {
    linecount++;
}

#endif


// From hashtable.c

// Hash table manipulation library

/*
 * Create a new hash table in memory and return a pointer to it.
 * Hash table needs to be freed with `ht_del`.
 */

ht_t *ht_new() {
    ht_t *ht;
    ht = malloc_or_die(sizeof(ht_t));
    ht->size = BASE_HT_SIZE;
    ht->used = 0;
    ht->body = _ht_body_new(BASE_HT_SIZE);

    return ht;
}

/*
 * (Internal) Create a new hash table body with size `size`.
 */

ht_item_t *_ht_body_new(size_t size) {
    return calloc_or_die(size, sizeof(ht_item_t));
}

/*
 * Looks up `key` in the hash table `t` and returns a pointer to its value.
 * If `key` does not exist, returns NULL.
 */

void *ht_getitem(ht_t *t, void *key) {
    size_t i = _ht_index(t, key);
    if (t->body[i].key == NULL)
        return NULL;
    return t->body[i].val;
}

/*
 * (Internal) Helper function to replace an item in a hash table.
 */

void _ht_replitem(ht_t *t, size_t pos, void *key, void *val) {
    // Check load factor and resize table
    if ((float) (t->used + 1) / (float) t->size > 0.8) {
        ht_grow(t, t->size * 2);
        pos = _ht_index(t, key);
    }
    // Add item to table
    t->used++;
    t->body[pos].key = key;
    t->body[pos].val = val;
}

/*
 * Add `key` to hash table `t` and associate value `val` to it.
 * If `key` already exists, does nothing. Note that `key` and `val`
 * will *not* be freed when removing item or destroying hash table.
 * Returns 0 if item was added, 1 otherwise.
 */

uint8_t ht_setitem(ht_t *t, void *key, void *val) {
    size_t i = _ht_index(t, key);
    // Key exists
    if (t->body[i].key != NULL)
        return 1;
    // Key does not exist, set item
    _ht_replitem(t, i, key, val);
    return 0;
}

/*
 * Unconditionally sets or replaces `key`'s value in hash table `t`.
 * See notes for `ht_setitem`.
 */

void ht_replitem(ht_t *t, void *key, void *val) {
    size_t i = _ht_index(t, key);
    _ht_replitem(t, i, key, val);
}

/*
 * Removes `key` from hash table.
 */

void ht_delitem(ht_t *t, void *key) {
    size_t i = _ht_index(t, key);
    size_t j, k;

    // Key does not exist
    if (t->body[i].key == NULL)
        return;

    j = i;
    // Rearrange following items
    for (;;) {
        j = (j+1) % t->size;

        // Slot is empty
        if (t->body[j].key == NULL)
            break;

        k = hash(t->body[j].key, strlen(t->body[j].key)) % t->size;

        if ((j > i && (k <= i || k > j)) ||
            (j < i && (k <= i && k > j)))
        {
            t->body[i].key = t->body[j].key;
            t->body[i].val = t->body[j].val;
            i = j;
        }
    }

    t->used--;
    t->body[i].key = NULL;
    t->body[i].val = NULL;
}

/*
 * (Internal) Finds index for `key` in hash table `t`. If `key`
 * is not in the table, returns the index of the first empty slot
 * in which `key` can be stored.
 */

size_t _ht_index(ht_t *t, void *key) {
    size_t i = hash(key, strlen(key)) % t->size;
    // Find key slot or first empty slot
    while (t->body[i].key != NULL && strcmp(t->body[i].key, key) != 0) {
        i = (i + 1) % t->size;
    }
    return i;
}

/*
 * Grows hash table `t` so it can host `newsize` keys.
 */

void ht_grow(ht_t *t, size_t newsize) {
    ht_item_t *oldbody = t->body;
    size_t oldsize = t->size;
    size_t i = 0;

    // Create new hash table body
    t->body = _ht_body_new(newsize);
    t->used = 0;
    t->size = newsize;

    // Move keys to new body
    for (; i < oldsize; i++) {
        if (oldbody[i].key != NULL)
            ht_setitem(t, oldbody[i].key, oldbody[i].val);
    }
    free(oldbody);
}

/*
 * Frees hash table `t`'s data structures from memory.
 * No keys or values are freed.
 */

void ht_del(ht_t *t) {
    // Free data structures
    free(t->body);
    free(t);
}


#ifdef DEBUG

/*
 * Dumps to stderr for debugging.
 */

void dump_hashtable(ht_t *t) {
    fprintf(stderr, "--- DUMP HASHTABLE ---\n");
    fprintf(stderr, "Size: %u, Used: %u\n", (unsigned int) t->size, (unsigned int) t->used);
    for (size_t i = 0; i < t->size; i++) {
        if (t->body[i].key != NULL) {
            fprintf(stderr, "[%u] %s\n", (
                    unsigned int) i, (char *) t->body[i].key);
        }
    }
    fprintf(stderr, "--- END DUMP HASHTABLE ---\n\n");
}

#endif


// From ramfs.c

// Actual in-memory file system implementation

/*
 * Create a new root node and return it.
 */

inline fs_node_t *ramfs_mkfs() {
    return _ramfs_mknode(NULL, NULL, TYPE_DIR, NULL);
}


/*
 * Creates a new node of type `type` under `root` at `path`.
 * Name is duplicated before storing it, make sure it is freed.
 * Returns 0 on success, -1 on error.
 */

int ramfs_create_node(fs_node_t *root, char *path, fs_node_type_t type) {
    char *newnode = NULL;
    fs_node_t *node = _ramfs_resolve_node(root, path, &newnode);

    // Check for error
    if (node == NULL || newnode == NULL) {
#ifdef DEBUG
        fprintf(stderr, "create node %s failed: node and newnode are null\n", path);
#endif
        return -1;
    }

    _ramfs_mknode(node, newnode, type, NULL);
    return 0;
}

/*
 * Creates a new file node under `root` at `path`.
 * Name is duplicated before storing it, make sure it is freed.
 * Returns 0 on success, -1 on error.
 */

int ramfs_create(fs_node_t *root, char *path) {
    return ramfs_create_node(root, path, TYPE_FILE);
}

/*
 * Creates a new directory node under `root` at `path`.
 * Name is duplicated before storing it, make sure it is freed.
 * Returns 0 on success, -1 on error.
 */

int ramfs_create_dir(fs_node_t *root, char *path) {
    return ramfs_create_node(root, path, TYPE_DIR);
}


/*
 * Find node at `path` under `root` and return its content.
 */

char *ramfs_read(fs_node_t *root, char *path) {
    char *newnode = NULL;
    char *backpath = calloc_or_die(strlen(path) + 1, sizeof(char));
    strcpy(backpath, path);
    fs_node_t *node = _ramfs_resolve_node(root, path, &newnode);

    // Check for error
    if (node == NULL || newnode != NULL || node->type != TYPE_FILE) {
#ifdef DEBUG
        if (newnode != NULL)
            fprintf(stderr, "read %s failed: node does not exist\n", backpath);
        if (node != NULL && node->type != TYPE_FILE)
            fprintf(stderr, "read %s failed: node is not a file\n", backpath);
        if (node == NULL)
            fprintf(stderr, "read %s failed: node is null\n", backpath);
        else
            dump_node(node);
        free(backpath);
#endif
        return NULL;
    }
#ifdef DEBUG
    free(backpath);
#endif
    return node->data.content;
}

/*
 * Write `content` to file node at `path` under `root`.
 * Content is duplicated before storing, make sure it is freed.
 * Returns 0 on success, -1 on error.
 */

int ramfs_write(fs_node_t *root, char *path, char *content) {
    char *newnode = NULL;
#ifdef DEBUG
    char *backpath = calloc_or_die(strlen(path) + 1, sizeof(char));
    strcpy(backpath, path);
#endif
    fs_node_t *node = _ramfs_resolve_node(root, path, &newnode);

    // Check for error
    if (node == NULL || newnode != NULL || node->type != TYPE_FILE) {
#ifdef DEBUG
        if (newnode != NULL)
            fprintf(stderr, "write %s failed: node does not exist\n", backpath);
        if (node != NULL && node->type != TYPE_FILE)
            fprintf(stderr, "write %s failed: node is not a file\n", backpath);
        if (node == NULL)
            fprintf(stderr, "write %s failed: node is null\n", backpath);
        else
            dump_node(node);
        free(backpath);
#endif
        return -1;
    }
#ifdef DEBUG
    free(backpath);
#endif

    size_t len = strlen(content);
    free(node->data.content);
    node->data.content = calloc_or_die(len + 1, sizeof(char));
    strncpy(node->data.content, content, len);

    return (int) len;
}

/*
 * Delete node at `path` under `root`. Both its name and content
 * are freed, make sure you don't keep any references.
 * Returns 0 on success, -1 on error.
 */

int ramfs_delete(fs_node_t *root, char *path) {
    char *newnode = NULL;
    fs_node_t *node = _ramfs_resolve_node(root, path, &newnode);

    // Do not delete root
    if (node == root) {
#ifdef DEBUG
        fprintf(stderr, "delete failed: trying to remove root");
#endif
        return -1;
    }

    // Check for error
    if (node == NULL || newnode != NULL)
        return -1;

    return _ramfs_rmnode(node, false);
}

/*
 * Recursively delete node and all its children at `path` under `root`.
 * Everything is freed, make sure you don't keep any references.
 * If path is an empty string or '/', the root node is NOT deleted.
 * Returns 0 if all nodes were deleted, -1 otherwise.
 */

int ramfs_delete_r(fs_node_t *root, char *path) {
    char *newnode = NULL;
    fs_node_t *node = _ramfs_resolve_node(root, path, &newnode);

    // Check for error
    if (node == NULL || newnode != NULL)
        return -1;

    return _ramfs_rmnode_r(node, false);
}

/*
 * Recursively search for `keyword` under `root`. `nres` is the pointer
 * to a size_t where the number of results will be stored.
 * Returns a sorted array of strings containing the path of each
 * result. The results and the array need to be disposed of.
 */

char **ramfs_find(fs_node_t *root, char *keyword, size_t *nres) {
    size_t len = FIND_ARRAY_SIZE;
    size_t pos = 0;
    *nres = 0;
    char **results = malloc_or_die(len*sizeof(char**));

    // Find all matching nodes first
    *nres += _ramfs_find(root, "", keyword, &results, &len, &pos);

    // Sort their paths
    qsort(results, *nres, sizeof(char *), _pathcmp);

    return results;
}

// Internal functions

/*
 * (Internal) Creates a new node of type `type` named `name` under `parent`
 * and returns it. If `parent` and `name` are NULL and `type` is TYPE_DIR,
 * a root node is created. If `data` is NULL, an hash table will be created
 * for TYPE_DIR, and an empty string for TYPE_FILE.
 * If node couldn't be created, NULL is returned.
 */

fs_node_t *_ramfs_mknode(fs_node_t *parent, char *name, fs_node_type_t type, void *data) {
    char *namecopy = NULL;

    // Files don't have children
    if (parent != NULL && parent->type == TYPE_FILE) {
#ifdef DEBUG
        fprintf(stderr, "mknode %s parent %s failed: file can't have children\n", name, parent->name);
#endif
        return NULL;
    }
    // Unless the node is root and is a directory, name can't be empty or NULL
    if ((parent == NULL && type != TYPE_DIR) ||
        (parent != NULL && (name == NULL || strlen(name) == 0))) {
#ifdef DEBUG
        fprintf(stderr, "mknode %s parent %s failed: empty name\n", name, parent->name);
#endif
        return NULL;
    }
    // If node is root, name must be NULL
    if (parent == NULL && name != NULL) {
#ifdef DEBUG
        fprintf(stderr, "mknode %s failed: root node can't have a name\n", name);
#endif
        return NULL;
    }

    if (name != NULL) {
        // Check max name length
        size_t nlen = strlen(name);
        if (nlen > MAX_NAME_LENGTH) {
#ifdef DEBUG
            fprintf(stderr, "create node %s failed: name too long\n", name);
#endif
            return NULL;
        }

        namecopy = calloc_or_die(nlen + 1, sizeof(char));
        // Copy the name so it isn't freed later
        strcpy(namecopy, name);
    }


    if (data == NULL && type == TYPE_DIR)
        data = ht_new();
    else if (data == NULL && type == TYPE_FILE)
        data = calloc_or_die(1, sizeof(char));

    uint8_t depth = (uint8_t) (parent != NULL ? parent->depth + 1 : 0);

    if (parent != NULL && depth == 0) {
        // Overflow <3 maximum depth exceeded
#ifdef DEBUG
        fprintf(stderr, "mknode %s parent %s failed: maximum depth reached\n", name, parent->name);
#endif
        return NULL;
    }

    fs_node_t *node = calloc_or_die(1, sizeof(fs_node_t));
    node->parent = parent;
    node->name = namecopy;
    node->type = type;
    node->data.raw = data;
    node->depth = depth;

    // If node is not root, add it to its parent
    if (parent != NULL)
        // If node already exists, error
        if (ht_setitem(parent->data.children, namecopy, node) != 0) {
            // We malloc'd memory so we need to free it.
            // The chance this event happens is so low that checking for
            // it earlier is worse than cleaning up.
#ifdef DEBUG
            fprintf(stderr, "mknode %s parent %s failed: node exists\n", name, parent->name);
#endif
            free(node);
            return NULL;
        }
    return node;
}

/*
 * (Internal) Delete node `node` and free its content. If
 * `no_rm_from_parent` is true, it is not removed from its parent.
 * Returns 0 on success, -1 on error.
 */

int _ramfs_rmnode(fs_node_t *node, uint8_t no_rm_from_parent) {
    // Make sure directory is empty
    if (node->type == TYPE_DIR && node->data.children->used > 0) {
#ifdef DEBUG
        fprintf(stderr, "rmnode %s failed: directory not empty\n", node->name);
        dump_node(node);
#endif
        return -1;
    }

    // Destroy node data
    if (node->type == TYPE_DIR) {
        ht_del(node->data.children);
    } else {
        free(node->data.content);
    }

    // Remove from parent (unless no_rm_from_parent is true)
    if (!no_rm_from_parent && node->parent != NULL)
        ht_delitem(node->parent->data.children, node->name);

    // Destroy node
    free(node->name);
    node->name = NULL;
    free(node);

    return 0;
}


/*
 * (Internal) Recursively delete node `node` and all its children. If
 * `no_rm_from_parent` is used internally to speed up deletion.
 * It should always be 0/false.
 * Returns 0 if all nodes were removed, -1 otherwise.
 */

int _ramfs_rmnode_r(fs_node_t *node, uint8_t no_rm_from_parent) {
    size_t i;
    ht_item_t *item;
    int error = 0;

    // Node has children
    if (node->type == TYPE_DIR && node->data.children->used > 0) {
        for (i = 0; i < node->data.children->size; i++) {
            if (node->data.children->body[i].key == NULL)
                continue;
            item = &node->data.children->body[i];
            // Always use no_rm_from_parent when recursively calling self
            // Hashtable is going to be deleted anyway, no need to remove
            // children from parent.
            error |= _ramfs_rmnode_r(item->val, true);
        }
        node->data.children->used = 0;
    }

    // Node is (now) a leaf
    if (node->parent != NULL  // node is not root and
        && (node->type == TYPE_FILE // (node is file or
            || (node->type == TYPE_DIR // node is dir and
                && node->data.children->used == 0))) { // dir is empty)
        error |= _ramfs_rmnode(node, no_rm_from_parent);
    }

    return error != 0 ? -1 : 0;
}

/*
 * (Internal) Returns human-readable path of `node` up to the root node.
 */

char *_ramfs_getpath(fs_node_t *node) {
    char *dirnames[255] = {0};
    fs_node_t *n = node;

    unsigned int len = 256;
    unsigned int pos = 0;
    char *string = malloc_or_die(len * sizeof(char));
    char *tmp;

    for (; n != NULL; n = n->parent)
        dirnames[n->depth] = n->name;

    string[0] = '/';
    pos++;

    for (int i = 1; i <= 255 && dirnames[i] != NULL; i++) {
        tmp = dirnames[i];
        for (int j = 0; tmp != NULL && tmp[j] != '\0'; j++) {
            // len-3 to make sure there are some spare chars
            if (pos + 1 > len - 3) {
                len += 256;
                string = realloc_or_die(string, len);
            }
            string[pos] = tmp[j];
            pos++;
        }
        string[pos] = '/';
        pos++;
    }

    // Remove trailing / if node is not directory
    if (node->type != TYPE_DIR)
        pos--;

    // Terminate key
    string[pos] = '\0';

    return string;
}

/*
 * (Internal) Walk tree starting from `root` to find the node at `path`.
 * If the node is found, it is returned. If the node was not found, but
 * its direct parent was, the parent is returned and the new node name
 * is stored into `newname`, so that the new node can be created.
 * Otherwise, NULL is returned.
 */

fs_node_t *_ramfs_resolve_node(fs_node_t *root, char *path, char **newname) {
    char *saveptr = NULL;
    char *tok;
    fs_node_t *node;
    fs_node_t *nodes[2] = {0};
    *nodes = root;
    uint8_t pos = 1;
    uint16_t count = 1;

    if ((tok = strtok_depau(path, "/", &saveptr)) != NULL && count <= 255) {
        do {
            if (strcmp(tok, "") == 0)
                continue;
            if (*newname != NULL) {
                // If we reach here it means that two nodes weren't found.
                // Path is too long, signal it by setting last node to root
#ifdef DEBUG
                fprintf(stderr, "resolve path %s (new name) failed: path too long\n",
                        path);
#endif
                nodes[pos] = root;
                nodes[!pos] = root;
                break;
            }
            // Parent node is a file, this can't be right
            if (nodes[!pos]->type == TYPE_FILE) {
#ifdef DEBUG
                fprintf(stderr, "resolve path parent %s failed: trying to find a file's child\n",
                        nodes[!pos]->name);
#endif
                nodes[pos] = root;
                nodes[!pos] = root;
                *newname = NULL;
                break;
            }
            nodes[pos] = ht_getitem(nodes[!pos]->data.children, tok);
            if (nodes[pos] == NULL && *newname == NULL) {
                // Node not found, it's probably a new node
                *newname = tok;
                count++;
                continue;
                // Go on to check if there is an extra token to read
            }
            pos = (uint8_t) !pos;
            count++;
        } while ((tok = strtok_depau(NULL, "/", &saveptr)) != NULL && count <= 255);
    }


    // Make sure no new node is created after depth 255
    if (count >= 256) {
#ifdef DEBUG
        fprintf(stderr, "resolve path may have failed: maximum depth exceeded\n");
#endif
        *newname = NULL;
    }

    if (nodes[!pos] != NULL)
        pos = (uint8_t) !pos;

    // Handle error
    if (nodes[pos] == root || nodes[pos] == NULL) {
        // count == 1 means path was "/"
        // count == 2 && *newname != NULL means path was "/dir" and "dir" did not exist
        if (count == 1 || (count == 2 && *newname != NULL))
            return root;
#ifdef DEBUG
        fprintf(stderr, "resolve node %s failed: could not resolve path\n", path);
#endif
        return NULL;
    }

    node = nodes[pos];
    return node;
}

/*
 * (Internal) Recursively search nodes matching `keyword` within `root`
 * and its children (if any). `results` is a pointer to an array of strings that
 * will be updated with any matches. `len` a pointer to the length of the array
 * and `pos` to the current position in it.
 * Returns the number of results found.
 */

size_t _ramfs_find(fs_node_t *node, char *curpath, char *keyword, char ***results, size_t *len, size_t *pos) {
    size_t i;
    size_t nres = 0;

    // node is not root
    if (node->name != NULL) {
        // Try to match current node
        if (strcmp(node->name, keyword) == 0) {
            if ((*pos)+1 >= *len) {
                *len += FIND_ARRAY_SIZE;
                *results = realloc_or_die(*results, *len*sizeof(char**));
            }
            (*results)[*pos] = strcat_auto(2, curpath, node->name);
            (*pos)++;
            nres++;
        }
    }
    if (node->type == TYPE_DIR && node->data.children->used > 0) {
        for (i = 0; i < node->data.children->size; i++) {
            if (node->data.children->body[i].key != NULL) {
                char *newpath = strcat_auto(3, curpath, node->name, "/");
                nres += _ramfs_find(node->data.children->body[i].val,
                                    newpath, keyword, results, len, pos);
                free(newpath);
            }
        }
    }


    return nres;
}

/*
 * (Internal) Helper function used to compare paths when sorting them
 */

int _pathcmp(const void *p1, const void *p2) {
    return strcmp(* (char * const *) p1, * (char * const *) p2);
}

#ifdef DEBUG
/*
 * (Internal) Dump node `node` to stderr for debugging.
 */

void dump_node(fs_node_t *node) {
    fprintf(stderr, "--- DUMP NODE (at %lu) ---\n", get_linecount());
    fprintf(stderr, "Address: %p\n", node);
    fprintf(stderr, "Name: %s\n", node->name);
    fprintf(stderr, "Type: %s\n", node->type == TYPE_FILE ? "file" : "directory");
    fprintf(stderr, "Depth: %i\n", node->depth);
    char *path = _ramfs_getpath(node);
    fprintf(stderr, "Path: %s\n", path);
    if (node->type == TYPE_DIR) {
        fprintf(stderr, "Children (%u/%u): ", (unsigned int) node->data.children->used,
                (unsigned int) node->data.children->size);
        for (size_t i = 0; i < node->data.children->size; i++) {
            if (node->data.children->body[i].key != NULL) {
                fs_node_t *child = node->data.children->body[i].val;
                fprintf(stderr, "[%c]%s, ", child->type == TYPE_FILE ? 'f' : 'd', child->name);
            }
        }
        fprintf(stderr, "\n");
    } else {
        fprintf(stderr, "Content: \"%s\"\n", node->data.content);
    }
    fprintf(stderr, "Is root: %s\n", node->parent == NULL ? "true" : "false");
    fprintf(stderr, "--- END DUMP NODE ---\n\n");

    free(path);
}
#endif


// From ramfs_wrapped.c

// Wrapper for ramfs.h

void ramfs_create_w(fs_node_t *root, char *cmd) {
    call_with_1(ramfs_create, root, cmd);
}

void ramfs_create_dir_w(fs_node_t *root, char *cmd) {
    call_with_1(ramfs_create_dir, root, cmd);
}

void ramfs_read_w(fs_node_t *root, char *cmd) {
    char *save_ptr;
    char *arg1 = readcmd(cmd, &save_ptr);
    char* ret = ramfs_read(root, arg1);
    if (ret == NULL)
        printf("no\n");
    else
        printf("contenuto %s\n", ret);
}

void ramfs_write_w(fs_node_t *root, char *cmd) {
    call_with_2(ramfs_write, root, cmd);
}

void ramfs_delete_w(fs_node_t *root, char *cmd) {
    call_with_1(ramfs_delete, root, cmd);
}

void ramfs_delete_r_w(fs_node_t *root, char *cmd) {
    call_with_1(ramfs_delete_r, root, cmd);
}

void ramfs_find_w(fs_node_t *root, char *cmd) {
    char *save_ptr;
    char *arg1 = readcmd(cmd, &save_ptr);
    size_t nres;
    char **results = ramfs_find(root, arg1, &nres);

    if (nres == 0)
        printf("no\n");
    else {
        for (size_t i = 0; i < nres; i++) {
            printf("ok %s\n", results[i]);
            free(results[i]);
        }
    }
    free(results);
}

// From main.c

int main() {
    char *cmdline = NULL;
    char *cmdline_saveptr;
    size_t cmdline_s = 0;
    ssize_t gl_ret;

    fs_node_t *root = ramfs_mkfs();

    do {
        gl_ret = getline_depau(&cmdline, &cmdline_s, stdin);
        cmdline = readcmd(cmdline, &cmdline_saveptr);

        // Empty line
        if (cmdline == NULL) {
            continue;
        }

#ifdef DEBUG
        printf("%lu %s ", get_linecount(), cmdline);
        if (get_linecount() == 0) {

            get_linecount();
        }
#endif

        // cmdline_saveptr is already at the beginning of next token
        if (strcmp(cmdline, "create") == 0) {
            ramfs_create_w(root, cmdline_saveptr);
        } else if (strcmp(cmdline, "create_dir") == 0) {
            ramfs_create_dir_w(root, cmdline_saveptr);
        } else if (strcmp(cmdline, "read") == 0) {
            ramfs_read_w(root, cmdline_saveptr);
        } else if (strcmp(cmdline, "write") == 0) {
            ramfs_write_w(root, cmdline_saveptr);
        } else if (strcmp(cmdline, "delete") == 0) {
            ramfs_delete_w(root, cmdline_saveptr);
        } else if (strcmp(cmdline, "delete_r") == 0) {
            ramfs_delete_r_w(root, cmdline_saveptr);
        } else if (strcmp(cmdline, "find") == 0) {
            ramfs_find_w(root, cmdline_saveptr);
        } else if (strcmp(cmdline, "exit") == 0) {
            break;
        } else {
            printf("no\n");
        }
#ifdef DEBUG
        increment_linecount();
#endif
    } while (gl_ret >= 0);

    // The same buffer is always used, eventually realloc'd.
    // We only need to free it once at the end.
    free(cmdline);
    // Remove root children
    _ramfs_rmnode_r(root, 0);
    // Remove root node
    _ramfs_rmnode(root, 0);

    return 0;
}

